<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css</title>
      <link href="/2019/10/29/css/"/>
      <url>/2019/10/29/css/</url>
      
        <content type="html"><![CDATA[<p class="description"></p><p><img src="https://" alt style="width:100%"></p><a id="more"></a><p>##</p><p>##</p><p>##</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>错题笔记</title>
      <link href="/2019/06/04/Exercises/"/>
      <url>/2019/06/04/Exercises/</url>
      
        <content type="html"><![CDATA[<p></p><p class="description"><br>临近期末考试也没有学什么新的东西，平时做做题查缺补漏，发现好多细碎点自己都不知道<br>总结一下 方便以后看， 常更<br></p><br><a id="more"></a><p></p><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><p><strong>Java 鲁棒性的特点</strong></p><blockquote><p>鲁棒：robust，稳定。<br>鲁棒性就是稳定性</p></blockquote><p>Java鲁棒性的特点如下：</p><blockquote><p>1:Java在编译和运行程序时都要对可能出现的问题进行检查，以防止错误的产生。<br>2:Java编译器可以查出许多其他语言运行时才能发现的错误。Java不支持指针操作，大大减少了错误发生的可能性。<br>3:Java具有异常处理的功能，当程序异常时，它能捕获并响应意外情况，以保证程序能稳妥地结束，计算机系统不会崩溃。</p></blockquote><p><strong>关于关键字</strong><br>null是关键字，NULL不是关键字，java区分大小写 所有的关键字都是小写</p><p><strong>线程</strong><br>程序运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            dianping();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.run();</span><br><span class="line">    System.out.print(<span class="string">"dazhong"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dianping</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"dianping"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>A:dazhongdianping<br>B:dianpingdazhong<br>C:AB都可能</p></blockquote><p>如果调用run（） 选b<br>如果调用start（） 选c<br>因为调用start后并不保证线程启动的顺序</p><p>##</p><p>##</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 查缺补漏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat安装配置</title>
      <link href="/2019/05/12/TomcatInstall/"/>
      <url>/2019/05/12/TomcatInstall/</url>
      
        <content type="html"><![CDATA[<p class="description"><br>简单讲解Tomcat的安装配置 以及目录结构 用户设置等<br></p><a id="more"></a><p>简介：<br>Tomcat 是一个免费的开放源代码的 Servlet 容器</p><h2 id="下载安装："><a href="#下载安装：" class="headerlink" title="下载安装："></a>下载安装：</h2><p>在<a href="https://tomcat.apache.org" target="_blank" rel="noopener">Tomcat官网</a>  Download处选择版本进行下载 此处选择Windows下64位的压缩包<br>  <img src="/2019/05/12/TomcatInstall/1.png" alt="下载1"><br>解压到目录文件之后 根据路径信息添加环境变量，进入计算机属性设置—&gt;高级系统设置—&gt;环境变量 添加</p><blockquote><p>变量名：CATALINA_HOME<br>变量值：你自己的安装路径</p></blockquote><blockquote><p>变量名：TOMCAT_HOME<br>变量值：你自己的安装路径</p></blockquote><p>同时在系统变量Path中添加</p><blockquote><p>%CATALINA_HOME%\lib<br>%TOMCAT_HOME%\bin<br><img src="/2019/05/12/TomcatInstall/4.png" alt="下载2"></p></blockquote><p>有时候出现问题 也可以直接添加所安装的Tomcat路径下的bin目录地址：（二选一）<br><img src="/2019/05/12/TomcatInstall/5.png" alt="下载2"></p><p>尝试启动Tomcat：<br>打开命令行  输入：</p><blockquote><p>startup</p></blockquote><p>之后 打开浏览器输入<a href="http://localhost:8080" target="_blank" rel="noopener">localhost:8080</a>看见欢迎界面表示配置成功<br><img src="/2019/05/12/TomcatInstall/6.png" alt="下载2"></p><h2 id="Tomcat-的目录结构"><a href="#Tomcat-的目录结构" class="headerlink" title="Tomcat 的目录结构"></a>Tomcat 的目录结构</h2><p>打开Tomcat安装路径 可以看到下面的结构<br><img src="/2019/05/12/TomcatInstall/8.png" alt="下载2"></p><blockquote><p>bin –&gt;启动和关闭 Tomcat 的脚本文件<br>conf  –&gt; 服务器的各种配置文件<br>lib   –&gt; 服务器和所有 web 应用程序需要访问的 jar 文件<br>logs  –&gt;日志文件<br>temp  –&gt;运行时产生的临时文件<br>webapps –&gt;发布 web 应用程序时，web 应用程序的目录及文件<br>work    –&gt;JSP 生成的 Servlet 源文件和字节码文件</p></blockquote><h2 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h2><p>Tomcat Manager的用户配置在 Tomcat安装目录/conf/tomcat-users.xml文件中进行管理<br><img src="/2019/05/12/TomcatInstall/7.png" alt="下载2"><br>一个user节点表示单个用户，属性username和password分别表示登录的用户名和密码，属性roles 表示该用户所具备的权限<br>添加用户时根据上面的格式更改自己的用户名密码即可 其他的不必修改</p><p>添加完成后再次启动Tomcat时 访问主页 输入用户名密码后即可进入自己的项目管理界面<br><img src="/2019/05/12/TomcatInstall/9.png" alt="下载2"></p><hr>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于TCP/IP的Java网络编程</title>
      <link href="/2019/05/07/Socket/"/>
      <url>/2019/05/07/Socket/</url>
      
        <content type="html"><![CDATA[<p class="description"><br>这学期学的计算机网络这门课 发现确实挺有意思 看完书和试验觉得看Java寄出的时候没有去细看网络编程这一部分，现在了解了网络知识之后回头来补这段java基础<br>本文主要是想记录一下初学计算机网络这门课的一些认识以及写一些用Java语言基于TCP/IP协议编程的实际操作中遇到的一些小坑<br>主要是Java进行编写客户服务器之间的通信 对网络基础只是简单的进行描述 并不会长篇大论<br>初学 理解不深 只是简单的进行了一个小的实验 帮助自己理解 以后再补充<br></p><a id="more"></a><h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><p>首先说一下以太网最基本最重要的知识——OSI参考模型</p><blockquote><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性</p></blockquote><p>简单来说就是推荐所有公司使用这个规范来控制网络，这样所有公司都有相同的规范，就能互联了<br>分七层从下到上分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层<br>但是由于这个模型太理想化  而我们在大多数情况下使用的都是<strong>TCP/IP</strong>五层模型：<br><strong>应用层 传输层 网络层 链路层 物理层</strong><br>而每一层都有他的主要功能和代表协议 此处不再细说 略见下图：<br><img src="/2019/05/07/Socket/协议.png" alt="TCP/IP"></p><p>而此处的Java网络编程（也叫Socket编程）就是使用位于传输层的<strong>TCP或者UDP</strong>协议进行的<br>之后我们来主要说一下这两个协议</p><h2 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP &amp; UDP"></a>TCP &amp; UDP</h2><p>两者都是位于传输层的协议<br><strong>面向连接的TCP（Transmission Control Protocol，传输控制协议）</strong></p><blockquote><p>1，可靠性：它是基于连接的协议，在正式收发数据前，必须和对方建立可靠的连接。（三次握手）<br>2，拥有拥塞控制 流量控制<br>3，不提供时间 最小吞吐量保证 安全性保证等<br>4，适用于传输要求高的<br>5，TCP进行通信的两个应用进程 客户端服务端</p></blockquote><p><strong>面向非连接的UDP协议</strong></p><blockquote><p>1，不可靠：不需要建立传输连接<br>2，没有拥塞控制，流量控制 吞吐量保证<br>3，发送数据结束时无需释放资源 速度快<br>4，适用于要求不高的少量数据<br>5，每个数据报大小限制在64K之内</p></blockquote><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>TCP在传输之前会进行三次沟通，一般称为“三次握手”，<br>传完数据断开的时候要进行四次沟通，一般称为“四次挥手”<br>此处先只说一下”三次握手”</p><p><strong>先形象化的说一下：</strong></p><blockquote><p>在晚上灯光暗的时候 你看见一个女生迎面走来 你不确定人不认识她：<br>你首先向妹子招手(syn)，妹子看到你向自己招手后，向你点了点头挤出了一个微笑(ack)。你看到妹子微笑后确认了妹子成功辨认出了自己(进入estalished状态)。</p></blockquote><blockquote><p>但是妹子有点不好意思，向四周看了一看，有没有可能你是在看别人呢，她也需要确认一下。妹子也向你招了招手(syn)，你看到妹子向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(ack)，妹子看到对方的微笑后确认了你就是在向自己打招呼(进入established状态)。两个人确认是熟人<br>于是你们打招呼成功。</p></blockquote><p>过程分四个动作：</p><blockquote><p>1，你招手<br>2，女生点头微笑<br>3，女生向你招手<br>4，你点头微笑</p></blockquote><p>2和3合并成一个动作 就形成了三次握手的形象化 其实本质上 三次握手第二次就是一个两个动作的整合 下面我们说一下专业化的语言</p><p><strong>三次握手：</strong><br>第一次：客户机给服务器发送请求连接（此时客户端不知道请求是否发送成功）<br>第二次：服务器给客户端反馈答复(服务端接收到 客户端发送成功进行反馈 服务器不知道自己是否发送成功)<br>第三次：客户端在给服务端反馈（双方都确认可以进行发送和接收）表示可以建立连接<br><strong><font size="4">需要用到的概念</font></strong><br>两个序号：</p><blockquote><p>（1）序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记<br>（2）确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。</p></blockquote><p>两个标志位：</p><blockquote><p>（A）ACK：确认序号有效。<br>（B）SYN：发起一个新连接。</p></blockquote><p>需要注意的是：<br>  （A）不要将确认序号ack与标志位中的ACK搞混了。<br>  （B）确认方ack=发起方req+1，两端配对。</p><p>主要过程：</p><blockquote><p>（1）第一次握手：Client将标志位SYN置为1，<br>随机产生一个值seq=X(就是客户端的数据初始地址)  并将该数据包发送给Server  Client进入SYN_SENT状态    等待Server确认。<br>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=X+1，随机产生一个值seq=Y(就是服务器端划分出的存储初始地址)，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br>（3）第三次握手：Client收到确认后，检查ack是否为X+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=Y+1，并将该数据包发送给Server，Server检查ack是否为Y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p></blockquote><p>过程如下图所示：<br><img src="/2019/05/07/Socket/Handshake.png" alt="Handshake"></p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>由 <strong><font color="FA8072">IP地址和端口号</font></strong> 组成的套接字<br>利用套接字开发应用程序被广泛使用  通信的两端都要有Socket<br>Socket允许程序把网络连接当成一个流 数据可以在两个Socket之间通过IO进行传输<br>一般主动发起通信的应用程序是<strong><font color="FA8072">客户端</font></strong> 等待通信请求的是<strong><font color="FA8072">服务端</font></strong></p><p><strong>网络编程实际上就是Socket编程</strong></p><h2 id="Socket编程实例"><a href="#Socket编程实例" class="headerlink" title="Socket编程实例"></a>Socket编程实例</h2><p>使用Socket进行基于TCP的简单编程<br>原理与IO流输入输出一致</p><blockquote><p>客户端给服务端发送消息 服务端输出信息到控制台上<br>服务器端收到信息后给客户端进行反馈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTCP</span> </span>&#123;</span><br><span class="line">  <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">8989</span>);</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">"I'm Client"</span>.getBytes());</span><br><span class="line"></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] b= <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len=inputStream.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//服务器端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8989</span>);</span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(b))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">            outputStream=socket.getOutputStream();</span><br><span class="line">            outputStream.write(<span class="string">"I have recieve your message"</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (outputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时先启动服务器端 再启动客户端<br>服务器端启动后无任何反馈 等待客户端启动  客户端启动后 两端的显示如下：</p><p><font face="黑体" size="5">服务器端：</font><br><img src="/2019/05/07/Socket/Server.png" alt="TCP/IP"></p><p><font face="黑体" size="5">客户端：</font><br><img src="/2019/05/07/Socket/Client.png" alt="TCP/IP"></p><h2 id="注意（排坑）"><a href="#注意（排坑）" class="headerlink" title="注意（排坑）"></a>注意（排坑）</h2><p>一：<br>如程序中所写Socket由IP地址和端口号两部分组成</p><blockquote><p>Socket=IP地址+端口号</p></blockquote><p>二：</p><blockquote><p>因为read()方式是堵塞式的：没有东西进行输入的话就会处于等待</p></blockquote><p>服务器端用read（）接受<br>但是服务端不知道客户端什么时候发送完数据  就一直处于等待  处于堵塞状态<br>下方程序因此无法进行 所以如果发送完数据的话 应该告诉服务端：我已经发送完毕<br><strong>类似于三次握手确认阶段的实现</strong></p><p>我第一次写的时候因为没有注意到这一点 导致服务器端接收到了第一次客户端发送到字段<br>但是一直处于运行状态 而客户端没有数据显示</p><p>此时需要在发送方写入方法之后加上一行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.shutdownOutput();</span><br></pre></td></tr></table></figure></p><p>用来告诉接收端：”我已经发送完毕” 可以开始接收</p><p>三：<br>使用完的Socket IO流等记得在程序中加上关闭语句 防止机器资源浪费</p><p><hr><br>写于计网期中考试完毕的一个反思夜晚  以后再进行补充</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String 之 intern()方法的测试分析</title>
      <link href="/2019/04/15/Java-intern/"/>
      <url>/2019/04/15/Java-intern/</url>
      
        <content type="html"><![CDATA[<p class="description"><br>这两天从新开始看深入理解Java虚拟机那本书了 但看到虚拟机数据区的关系时发现，之前String里面的intern方法知识点有点模糊 以前也没细看过<br>今天问了问同学 查了一下资料 开始补坑<br>记录一下Java String类里面的一个方法理解<br></p><a id="more"></a><h2 id="new-String-amp-String"><a href="#new-String-amp-String" class="headerlink" title="new String() &amp; String"></a>new String() &amp; String</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"maccha"</span>);</span><br></pre></td></tr></table></figure><p>定义了几个对象<br><em>回答：若常量池中已经存在 “maccha”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存在 “maccha”，则先创建后引用，也就是有两个。</em></p><p>String str=”maccha”；<br>String<br>str=new String (“maccha”);的区别：<br>在这里，先说下”常量池”概念。<br><strong>常量池</strong>(constant pool)<br>    指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、<br>    法、接口等中的常量，也包括字符串常量。</p><h3 id="Test1："><a href="#Test1：" class="headerlink" title="Test1："></a><strong>Test1：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String a0 = <span class="string">"maccha"</span>;   </span><br><span class="line">String a1 = <span class="string">"maccha"</span>;   </span><br><span class="line">String a2 = <span class="string">"mac"</span>+<span class="string">"cha"</span>;</span><br><span class="line">System.out.println(a0==a1);</span><br><span class="line">System.out.println(a0==a2);</span><br></pre></td></tr></table></figure><p>结果为：<br><img src="/2019/04/15/Java-intern/demo1.png" alt="输出1"><br>首先，我们要知道Java会确保一个字符串常量只有一个拷贝。<br>因为例子中的s0和s1中的”maccha”都是字符串常量，它们在编译期就确定了，<br>所以s0==s1为true；<br>而”mac”和”cha”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，<br>自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，<br>所以s2也是常量池中”maccha”的一个引用。<br>我们得出s0==s1==s2;<br>用<strong>new</strong>创建的字符串不是常量，不能在编译期就确定，<br>所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。</p><h3 id="Test2："><a href="#Test2：" class="headerlink" title="Test2："></a><strong>Test2：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s0 = <span class="string">"maccha"</span>;</span><br><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"maccha"</span>);</span><br><span class="line">String s2 = <span class="string">"mac"</span>+<span class="keyword">new</span> String (<span class="string">"cha"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s0 == s1);</span><br><span class="line">System.out.println(s0 == s2);</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure><p>结果为：<br><img src="/2019/04/15/Java-intern/demo2.png" alt="输出2"><br>例2中s0还是常量池中”maccha”的引用<br>s1因为无法在编译期确定，所以是运行时创建的新对象”maccha”的引用<br>s2因为有后半部分new String(“cha”)所以也无法在编译期确定，<br>也是一个新创建对象”maccha”的应用</p><h2 id="String-intern-："><a href="#String-intern-：" class="headerlink" title="String.intern()："></a>String.intern()：</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p><strong>语法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intern</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p><strong>返回值</strong><br><em>一个字符串，内容与此字符串相同，但一定取自具有唯一字符串的池。</em></p><p>存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。<br>就是JVM书中所说的运行时常量池<br>String的intern()方法就是扩充常量池的最常见的方法运用</p><blockquote><p>当一个String实例str调用intern()方法时，<br>Java查找常量池中是否有相同Unicode的字符串常量<br>如果有，则返回其的引用，<br>如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用</p></blockquote><h3 id="Test3："><a href="#Test3：" class="headerlink" title="Test3："></a><strong>Test3：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s0= <span class="string">"maccha"</span>;</span><br><span class="line">String s1= <span class="keyword">new</span> String(<span class="string">"maccha"</span>);</span><br><span class="line">String s2= <span class="keyword">new</span> String(<span class="string">"maccha"</span>);</span><br><span class="line">System.out.println(s0==s1 );</span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"></span><br><span class="line">s1.intern();</span><br><span class="line">s2=s2.intern(); <span class="comment">//把常量池中“maccha”的引用赋给s2</span></span><br><span class="line"></span><br><span class="line">System.out.println(s0==s1);</span><br><span class="line"></span><br><span class="line">System.out.println(s0==s1.intern() );</span><br><span class="line"></span><br><span class="line">System.out.println(s0==s2 );</span><br></pre></td></tr></table></figure><p>结果为：<br><img src="/2019/04/15/Java-intern/demo3.png" alt="输出3"></p><h3 id="Test4："><a href="#Test4：" class="headerlink" title="Test4："></a><strong>Test4：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不声名"maccha"常量</span></span><br><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"maccha"</span>);</span><br><span class="line">String s2=s1.intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1==s1.intern() );</span><br><span class="line">System.out.println(s1+<span class="string">" "</span>+s2 );</span><br><span class="line">System.out.println(s2==s1.intern() );</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2019/04/15/Java-intern/demo4.png" alt="输出4"><br>在这个类中我们没有声名一个”maccha”常量<br>常量池中最初是没有”maccha”的<br>当我们调用s1.intern()后就在常量池中新添加了一个”maccha”常量<br>原来的不在常量池中的”maccha”仍然存在，所以并不是</p><blockquote><p>如果在表中没有相同值的字符串,将自己的地址注册到常量池中</p></blockquote><p>s1==s1.intern()为false说明原来的“maccha”仍然存在；<br>s2现在为常量池中“maccha”的地址，所以有s2==s1.intern()为true。</p><p>查资料时发现有好多讲的挺细致的<br>收货不小,下面是查资料时的的详细介绍:<br><a href="https://blog.csdn.net/qq_41928979/article/details/89313835" target="_blank" rel="noopener">String 之 new String（）和 intern（）方法深入分析</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> String类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下使用VMware安装Ubantu虚拟机实操记录</title>
      <link href="/2019/04/13/VMwareInstall/"/>
      <url>/2019/04/13/VMwareInstall/</url>
      
        <content type="html"><![CDATA[<h2 id="小记："><a href="#小记：" class="headerlink" title="小记："></a>小记：</h2><p>刚刚开通博客 正好刚重新做了一遍实验课 就拿这篇来用Markdown写博客练练手 顺便回忆一下安装虚拟机的过程<br>此篇记录内容包括：</p><p>   安装VMware    </p><p>   创建虚拟机</p><p>   虚拟机上Ubantu系统的安装</p><p>详见下文：<br><a id="more"></a></p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>windows操作系统物理机<br>VMware Workstation 软件（可以在网上下载）<br>Ubantu-14.04.6镜像文件（其他版本都大同小异，这里以Ubantu14.04为例）<br>另外一点外网原因可能网站上下载的有些慢 提供一下我的下载地址,还是蛮快的:<br><a href="http://mirrors.aliyun.com/ubuntu-releases/14.04/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/14.04/</a><br>里面有各种不同的版本   </p><h2 id="虚拟机的下载："><a href="#虚拟机的下载：" class="headerlink" title="虚拟机的下载："></a>虚拟机的下载：</h2><p>1.进入<a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener">VMware</a>官网，点击下载，再点击图中标记的Workstation Pro，如下图所示。<br>  <img src="/2019/04/13/VMwareInstall/download1.png" alt="下载1"><br>2.根据操作系统选择合适的产品，在这里以Windows系统为例，点击转至下载，如下图所示<br>  <img src="/2019/04/13/VMwareInstall/download2.jpg" alt="下载2"><br>3.在1处可以选择版本，默认为最新版本。选择好版本后点击立即下载，下载速度很慢的话，建议科学上网一下。<br>  <img src="/2019/04/13/VMwareInstall/download3.png" alt="下载3"></p><h2 id="虚拟机的安装："><a href="#虚拟机的安装：" class="headerlink" title="虚拟机的安装："></a>虚拟机的安装：</h2><p>1.打开.exe文件， 即可开始安装。<br>(因为我已经安装过了所以此处选了一个文件包里的汉化版进行演示，还是建议选用原版)<br>  <img src="/2019/04/13/VMwareInstall/VMwareInstall1.png" alt="安装1"><br> 2.安装位置默认在C盘下，在这里我选择安装在F盘，安装路径尽量不要有中文。<br>  <img src="/2019/04/13/VMwareInstall/VMwareInstall2.png" alt="安装2"><br>3.等待安装就好了。   </p><p>4.安装成功后，第一次运行程序会让输入密钥，这个自己百度，分享一下我搜的密钥 有能用的可以用一下：<br>CG54H-D8D0H-H8DHY-C6X7X-N2KG6<br>ZC3WK-AFXEK-488JP-A7MQX-XL8YF<br>AC5XK-0ZD4H-088HP-9NQZV-ZG2R4<br>ZC5XK-A6E0M-080XQ-04ZZG-YF08D<br>ZY5H0-D3Y8K-M89EZ-AYPEG-MYUA8<br>FF590-2DX83-M81LZ-XDM7E-MKUT4<br>FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA<br>CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD<br>AALYG-20HVE-WHQ13-67MUP-XVMF3<br><img src="/2019/04/13/VMwareInstall/VMwareInstall3.jpg" alt="安装3"><br>5.点击完成即可。<br>6.运行 可以看到以下界面即安装完成：<br><img src="/2019/04/13/VMwareInstall/over.jpg" alt="界面">  </p><h2 id="创建新的虚拟机"><a href="#创建新的虚拟机" class="headerlink" title="创建新的虚拟机"></a>创建新的虚拟机</h2><p>1.打开VMware Workstation点击创建新的虚拟机  选择自定义点击下一步：<br>典型的虚拟机大部分是系统默认选项我们没法改，<br>你如果只是为了单纯创建个虚拟机不做其他用途可以选择典型 此处我们选择自定义<br><img src="/2019/04/13/VMwareInstall/create1.png" alt="创建1"><br>2 选择安装虚拟机的版本 点击下一步<br><img src="/2019/04/13/VMwareInstall/create2.png" alt="创建2"><br>3 选择稍后安装操作系统 点击下一步<br><img src="/2019/04/13/VMwareInstall/create3.png" alt="创建3"><br>4  客户机系统选择Linux  版本我们选择安装的Ubantu 64位<br>（按照电脑自身配置选择64或者32位）一般向下兼容<br><img src="/2019/04/13/VMwareInstall/create4.png" alt="创建4"><br>5 虚拟名称 可以随便选择<br>位置最好创建一个新的文件夹存放虚拟机对应文件存储目录 也可以直接默认<br><img src="/2019/04/13/VMwareInstall/create5.png" alt="创建5"><br>6 处理器这个根据你电脑情况来选<br>如果你的电脑是八核你可以选2核或4核<br>如果你处理器是四核你可以选1核或2核<br>只要不超过你电脑本身核数就行，超过了你的虚拟机就可能启动不起来<br>演示就直接默认选择了<br><img src="/2019/04/13/VMwareInstall/create6.png" alt="创建6"><br>7 虚拟机内存这个也是根据你电脑自身情况来选<br>最好按推荐来，如果虚拟机内存过高会影响你电脑流畅性 够用就好<br><img src="/2019/04/13/VMwareInstall/create7.png" alt="创建7"><br>8 可以上网 选择桥接网络或者net模式，演示选择使用桥接网络<br><img src="/2019/04/13/VMwareInstall/create8.png" alt="创建8"><br>9 IO控制器类型和磁盘类型推荐默认即可 下一步<br><img src="/2019/04/13/VMwareInstall/create9.png" alt="创建9"><br><img src="/2019/04/13/VMwareInstall/create10.png" alt="创建10"><br> 10 选择创建新磁盘<br><img src="/2019/04/13/VMwareInstall/create11.png" alt="创建11"><br>  磁盘大小只是我们给定的空间，后面进行分区时才是它的真实大小<br>  不能太小，太小系统就装不上了，默认分配20G即可<br>  选择拆分多个文件。<br><img src="/2019/04/13/VMwareInstall/create12.png" alt="创建12"><br> 11 储存磁盘位置 自己选择<br><img src="/2019/04/13/VMwareInstall/create13.png" alt="创建13"><br>12 点击自定义硬件 并在CD/DVD 处选择使用ISO映像文件<br><img src="/2019/04/13/VMwareInstall/create14.png" alt="创建14"><br>此处 把开头下载好的ISO文件选中 添加即可<br><img src="/2019/04/13/VMwareInstall/create15.png" alt="创建15"><br> 完成！</p><h1 id="Linux系统安装"><a href="#Linux系统安装" class="headerlink" title="Linux系统安装"></a>Linux系统安装</h1><p>1 点击开启虚拟机 点击Install Ubantu即可<br><img src="/2019/04/13/VMwareInstall/last1.png" alt="系统1"><br>2 直接点击继续即可 下同<br><img src="/2019/04/13/VMwareInstall/last2.png" alt="系统2"><br><img src="/2019/04/13/VMwareInstall/last3.png" alt="系统3">    </p><p>3 选择所在地区 此处选择上海就行<br><img src="/2019/04/13/VMwareInstall/last4.png" alt="系统4">  </p><p>4 选择键盘的文字 英语最好 当然觉得别扭的话可以选择中文<br><img src="/2019/04/13/VMwareInstall/last5.png" alt="系统5">  </p><p>5 在此处设置你的用户名和密码 下面可以选择自动登录和每次输入密码登录<br>  觉得麻烦可以选第一个自动登录<br><img src="/2019/04/13/VMwareInstall/last6.png" alt="系统6"><br> 重启即可完成安装系统</p><h2 id="到此结束啦-这么多图-你的虚拟机装好了吗"><a href="#到此结束啦-这么多图-你的虚拟机装好了吗" class="headerlink" title="到此结束啦  这么多图  你的虚拟机装好了吗"></a>到此结束啦  这么多图  你的虚拟机装好了吗</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 基础 </tag>
            
            <tag> 安装配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/04/13/hello-world/"/>
      <url>/2019/04/13/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><a id="more"></a><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
